/**
 * @file    DataLogger.cc
 * @author  Mohammadreza Zakeri
 * @date    2025-06-04
 *
 * @brief   Implementation of the master-thread JSON / TSV run-summary writer.
 *
 * ────────────────────────────────────────────────────────────────────────────
 *  Thread model
 *  ────────────────────────────────────────────────────────────────────────────
 *  • Exactly ONE instance of DataLogger is created in ActionInitialization
 *    *before* worker threads are spawned (in the ctor or BuildForMaster()).
 *  • Only the   master   thread ever calls any DataLogger method:
 *        ┌────────────────────────────────────────────────────────────────┐
 *        │ RunAction::BeginOfRunAction (master)  → InitOutputFiles()      │
 *        │ RunAction::EndOfRunAction   (master)  → DumpRunSummary()       │
 *        └────────────────────────────────────────────────────────────────┘
 *  • Worker threads never see the DataLogger pointer, so no locks are needed.
 *
 *  If you *later* decide you want workers to append rows to events.tsv,
 *  protect `tsv_` with `tsvMutex_` (already declared in the header).
 *
 * ────────────────────────────────────────────────────────────────────────────
 */

#include "DataLogger.hh"           // declaration

/*────────────────────────────── C++ stdlib ────────────────────────────────*/
#include <chrono>
#include <filesystem>
#include <iomanip>
#include <sstream>
#include <string>

/*──────────────────────────────── Geant4 ──────────────────────────────────*/
#include "G4ios.hh"
#include "G4Threading.hh"          // G4Threading::IsMasterThread()

/*────────────────────────── project headers  ──────────────────────────────*/
#include "DetectorConstruction.hh" // for cone dictionary helper

using namespace util;
namespace fs = std::filesystem;    // shorthand

/*══════════════════════════════════════════════════════════════════════════*/
/* 1.  Ctor / Dtor                                                         */
/*══════════════════════════════════════════════════════════════════════════*/

DataLogger::DataLogger(const std::string& outDir)
: outDir_{outDir}
{
    /* The top-level “results” directory is created once (idempotent). */
    fs::create_directories(outDir_);
}

DataLogger::~DataLogger()
{
    if (tsv_.is_open()) tsv_.close();
}

/*══════════════════════════════════════════════════════════════════════════*/
/* 2.  InitOutputFiles – called ONCE in BeginOfRunAction (master)           */
/*══════════════════════════════════════════════════════════════════════════*/

void DataLogger::InitOutputFiles(const geom::GeometryConfig& cfg)
{
    if (isInitialized_) {
        G4cerr << "[DataLogger] ERROR: InitOutputFiles() called twice!\n";
        return;
    }

    /*------------------------------------------------------------------*/
    /** 2.1  Build run-specific sub-directory:  results/20250604T120155 */
    /*------------------------------------------------------------------*/
    const auto   now   = std::chrono::system_clock::now();
    const auto   t_c   = std::chrono::system_clock::to_time_t(now);
    char stamp[32];
    std::strftime(stamp, sizeof(stamp), "%Y%m%dT%H%M%S", std::localtime(&t_c));

    subDir_   = outDir_ + "/" + stamp;
    tsvPath_  = subDir_ + "/events.tsv";
    jsonPath_ = subDir_ + "/run.json";

    fs::create_directories(subDir_);

    /*------------------------------------------------------------------*/
    /** 2.2  Write TSV header (cone dictionary, column names, etc.)     */
    /*------------------------------------------------------------------*/
    tsv_.open(tsvPath_, std::ios::out);
    if (!tsv_) {
        G4cerr << "[DataLogger] ERROR: cannot open " << tsvPath_ << G4endl;
        return;
    }

    std::ostringstream ts;
    ts << "# ------------------------------------------------------------\n"
       << "# Event log file\n"
       << "# Generated by muAlphaSim at "
       << std::put_time(std::localtime(&t_c), "%Y-%m-%d %H:%M:%S") << "\n"
       << "# Author: Mohammadreza Zakeri\n"
       << "# ------------------------------------------------------------\n"
       << "# Cone ID dictionary:\n";

//     /* Build the cone dictionary from GeometryConfig (faster than
//        casting DetectorConstruction again – cfg is already here). */
//     unsigned cid = 1;
//     for (const auto& p : cfg.panels) 
// {
//         for (unsigned j = 0; j < p.nx * p.ny; ++j, ++cid) 
// 		{
//             const auto ctr = cfg.ConeGlobalCenter(cid - 1); // helper you might have
//             ts << "# Panel: " << p.panelIdx + 1
//                << ",\t Cone: " << cid
//                << ",\t center = (" << ctr.x_nm << " nm, " << ctr.y_nm << " nm)\n";
//         }
//     }
//     ts << "# Panel\tCone\trho_local[m]\tz_local[m]\n";

	/* Build the cone dictionary from GeometryConfig  ----------------------- */
	unsigned cid = 1;                     // global CONE id  (1-based)
	std::size_t panelIdx = 1;             // global PANEL id (1-based)

	for (const auto& p : cfg.panels)
	{
		const unsigned conesInPanel = static_cast<unsigned>(p.nx * p.ny);

		for (unsigned local = 0; local < conesInPanel; ++local, ++cid)
		{
			const auto ctr = cfg.ConeGlobalCenter(cid - 1);   // flattened → centre (nm)

			ts << "# Panel: " << panelIdx
			<< ",\t Cone: "  << cid
			<< ",\t center = (" << ctr.x_nm << " nm, " << ctr.y_nm << " nm)\n";
		}
		++panelIdx;    // next panel
	}

	// ts << "# Panel\tCone\trho_local[m]\tz_local[m]\n";

    tsv_ << ts.str();
    tsv_.flush();

    isInitialized_ = true;

    G4cout << "[DataLogger] > Created " << tsvPath_ << G4endl;
}

/*══════════════════════════════════════════════════════════════════════════*/
/* 3.  DumpRunSummary – called ONCE in EndOfRunAction (master)              */
/*══════════════════════════════════════════════════════════════════════════*/

void DataLogger::DumpRunSummary(const geom::GeometryConfig& cfg,
                                unsigned long               nEvents,
                                unsigned long               nIon,
                                unsigned long               nCap,
                                const std::vector<unsigned>& coneIon,
                                const std::vector<unsigned>& coneCap,
                                const std::vector<unsigned>& panelIon,
                                const std::vector<unsigned>& panelCap)
{
    /*------------------------------------------------------------------*/
    /** 3.1  Finalize TSV footer                                        */
    /*------------------------------------------------------------------*/
    if (tsv_.is_open()) {
        tsv_ << "# ------------------------------------------------------------\n"
             << "# Total mu-α ionization events: " << nIon << "\n"
             << "# Total mu-α capture    events: " << nCap << "\n"
             << "# ------------------------------------------------------------\n"
             << "#   			End of event log file \n"
             << "# ------------------------------------------------------------\n";
        tsv_.close();

        G4cout << "[DataLogger] > Finalized " << tsvPath_ << G4endl;
    }

    /*------------------------------------------------------------------*/
    /** 3.2  Open JSON summary file                                     */
    /*------------------------------------------------------------------*/
    std::ofstream js(jsonPath_);
    if (!js) {
        G4cerr << "[DataLogger] ERROR: cannot open " << jsonPath_ << G4endl;
        return;
    }

    /*------------------------------------------------------------------*/
    /** 3.3  Simple stats (fractions + Wilson errors)                   */
    /*------------------------------------------------------------------*/
    const double N  = static_cast<double>(nEvents);
    const double fI = N ? nIon / N : 0.0;
    const double fC = N ? nCap / N : 0.0;

    auto wilson95 = [N](unsigned long k, double p) -> double
    {
        if (k == 0 || k == N) return 3.0 / N;      // “rule of three”
        return std::sqrt(p * (1.0 - p) / N);
    };

    /*------------------------------------------------------------------*/
    /** 3.4  Write flat JSON object (easy for jq / pandas)              */
    /*------------------------------------------------------------------*/
    js << std::fixed << std::setprecision(6);
    js << "{\n"
       << "  \"n_events\"      : " << nEvents << ",\n"
       << "  \"n_ion\"         : " << nIon    << ",\n"
       << "  \"n_capture\"     : " << nCap    << ",\n"
       << "  \"ion_frac\"      : " << fI      << ",\n"
       << "  \"ion_err\"       : " << wilson95(nIon, fI) << ",\n"
       << "  \"cap_frac\"      : " << fC      << ",\n"
       << "  \"cap_err\"       : " << wilson95(nCap, fC) << ",\n"
       << "  \"ion_cap_ratio\" : " << (nCap ? double(nIon) / nCap : 0.0) << ",\n";

    /*── Geometry parameters (flat) ───────────────────────────────────*/
    js << "  \"geometry\" : {\n"
       << "    \"r_tip_nm\"    : " << cfg.cone.r_tip_nm   << ",\n"
       << "    \"r_base_nm\"   : " << cfg.cone.r_base_nm  << ",\n"
       << "    \"h_cone_nm\"   : " << cfg.cone.h_cone_nm  << ",\n"
       << "    \"gap_nm\"      : " << cfg.gap_nm          << ",\n"
       << "    \"r_middle_nm\" : " << cfg.r_middle_nm     << ",\n"
       << "    \"r_outer_nm\"  : " << cfg.r_outer_nm      << "\n"
       << "  },\n";

    /*── Per-panel / per-cone tallies (optional, but useful) ──────────*/
    js << "  \"panel_stats\" : [\n";
    for (std::size_t i = 0; i < panelIon.size(); ++i) {
        js << "    { \"panel\" : " << (i+1)
           << ", \"ion\" : "      << panelIon[i]
           << ", \"cap\" : "      << panelCap [i] << " }"
           << (i+1 < panelIon.size() ? "," : "") << '\n';
    }
    js << "  ],\n";

    js << "  \"cone_stats\" : [\n";
    for (std::size_t i = 0; i < coneIon.size(); ++i) {
        js << "    { \"cone\" : " << (i+1)
           << ", \"ion\" : "     << coneIon[i]
           << ", \"cap\" : "     << coneCap[i] << " }"
           << (i+1 < coneIon.size() ? "," : "") << '\n';
    }
    js << "  ]\n}\n";

    /*------------------------------------------------------------------*/
    /** 3.5  Done!                                                      */
    /*------------------------------------------------------------------*/
    js.close();
    G4cout << "[DataLogger] > Wrote " << jsonPath_ << G4endl;
}

/*──────────────────────────── end of file ─────────────────────────────────*/